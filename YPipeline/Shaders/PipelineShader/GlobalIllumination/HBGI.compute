#pragma kernel HBGIKernel

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma multi_compile _ _DEFERRED_RENDERING

#include "../../../ShaderLibrary/Core/YPipelineCSCore.hlsl"
#include "../../../ShaderLibrary/RandomLibrary.hlsl"
#include "../../../ShaderLibrary/EncodingLibrary.hlsl"
#include "../../../ShaderLibrary/GlobalIllumination/DiffuseGICommon.hlsl"

// --- Local Textures ---
RWTexture2D<float4> _OutputTexture;
Texture2D<float4> _InputTexture;
Texture2D<float4> _IrradianceHistory;

// --- Global Textures & Samplers ---
#ifdef _DEFERRED_RENDERING
TEXTURE2D(_GBuffer1);
#define NORMAL_TEX _GBuffer1
#else
TEXTURE2D(_ThinGBuffer);
#define NORMAL_TEX _ThinGBuffer
#endif

TEXTURE2D(_CameraDepthTexture);
SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_PointClamp);

// --- Global Variables ---
float4 _CameraBufferSize; // x: 1.0 / bufferSize.x, y: 1.0 / bufferSize.y, z: bufferSize.x, w: bufferSize.y
float4 _Jitter; // Halton (-0.5, 0.5), xy: 1.0 / jitter, zw: jitter
float4 _TimeParams; // x: frameCount, y: 1.0 / frameCount

// --- Local Variables ---
float4 _TextureSize; // x: 1.0 / width, y: 1.0 / height, z: width, w: height


TEXTURE2D(_STBN128Scalar3);
float4 _STBN128Scalar3_TexelSize;
TEXTURE2D(_STBN128Vec3);
float4 _STBN128Vec3_TexelSize;
TEXTURE2D(_STBN128UnitVec3);
float4 _STBN128UnitVec3_TexelSize;
TEXTURE2D(_STBN128CosineUnitVec3);
float4 _STBN128CosineUnitVec3_TexelSize;

// ----------------------------------------------------------------------------------------------------
// Input
// ----------------------------------------------------------------------------------------------------




// ----------------------------------------------------------------------------------------------------
// SSDO Utility Functions
// ----------------------------------------------------------------------------------------------------

float LoadDepth(int2 pixelCoord)
{
    return LOAD_TEXTURE2D_LOD(_CameraDepthTexture, pixelCoord, 0).r;
}

float3 LoadAndDecodeNormal(int2 pixelCoord)
{
    float3 packedNormalWS = LOAD_TEXTURE2D_LOD(NORMAL_TEX, pixelCoord, 0).rgb;
    return DecodeNormalFrom888(packedNormalWS);
}

// ----------------------------------------------------------------------------------------------------
// HBGI Kernel
// ----------------------------------------------------------------------------------------------------

float3 GenerateHemisphereSamples(float2 xi, float scale)
{
    float phi = PI * (2.0 * xi.x - 1.0);
    float cosTheta = 1 - xi.y;
    float sinTheta = sqrt(1 - cosTheta * cosTheta);
    
    float r = scale * scale; // distribute more samples closer to the hemisphere origin
    return float3(r * sinTheta * cos(phi), r * cosTheta, r * sinTheta * sin(phi));
}

float3 GenerateCosineWeightedHemisphereSamples(float2 xi, float scale)
{
    float phi = PI * (2.0 * xi.x - 1.0);
    float cosTheta = sqrt(1 - xi.y);
    float sinTheta = sqrt(1 - cosTheta * cosTheta);
    
    float r = scale * scale; // distribute more samples closer to the hemisphere origin
    return float3(r * sinTheta * cos(phi), r * cosTheta, r * sinTheta * sin(phi));
}

[numthreads(8, 8, 1)]
void HBGIKernel(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    float2 screenUV = (float2(pixelCoord) + float2(0.5, 0.5)) * _TextureSize.xy;
    
    // ------------------------- Get Origin Position -------------------------
    
    float originDepth = LoadDepth(pixelCoord);
    float originLinearDepth = GetViewDepthFromDepthTexture(originDepth);
    float4 originNDC = GetNDCFromUVAndDepth(screenUV, originDepth);
    float3 originWS = TransformNDCToWorld(originNDC, UNITY_MATRIX_I_VP);
    float3 viewDir = GetWorldSpaceNormalizedViewDir(originWS);
    
    if (originDepth < 1e-7)
    {
        _OutputTexture[id.xy] = float4(0.0, 0.0, 0.0, originLinearDepth);
        return;
    }
    
    // ------------------------- Get Normal & Build Left-Handed TBN -------------------------
    
    float3 normalWS = LoadAndDecodeNormal(pixelCoord); // N

    float3 up = abs(normalWS.y) > 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);
    float3 tangent = normalize(cross(up, normalWS)); // T
    float3 binormal = normalize(cross(tangent, normalWS)); // B
    
    // ------------------------- Random Rotation -------------------------
    
    float randomRadian = (LOAD_TEXTURE2D_LOD(_STBN128Scalar3, id.xy % _STBN128Scalar3_TexelSize.zw, 0).r + _Jitter.z) * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));
    
    // ------------------------- SSDO Loop -------------------------
    
    float3 irradiance = 0.0;
    float intensity = 1.0;
    float sampleCount = 24;
    float radius = 1;
    
    // float count = 0;
    
    UNITY_UNROLL
    for (int i = 0; i < sampleCount; i++)
    {
        // ------------------------- Generate Hemisphere Samples -------------------------
            
        float2 xi = k_Sobol[i + 1];
        float scale = pow(max(k_Halton[i + 1].y, 0.01), 1/3);
        float3 dirTS = GenerateCosineWeightedHemisphereSamples(xi, scale);
        dirTS.xz = mul(rotation, dirTS.xz);

        // ------------------------- Sample Depth Buffer -------------------------
            
        float3 dirWS = tangent * dirTS.x + normalWS * dirTS.y + binormal * dirTS.z;
        float3 sampleWS = originWS + dirWS * radius;
        float4 sampleHCS = TransformWorldToHClip(sampleWS);
        sampleHCS.xyz /= sampleHCS.w;
        float2 uv = sampleHCS.xy * 0.5 + 0.5;

        #if UNITY_UV_STARTS_AT_TOP
        uv.y = 1.0f - uv.y;
        #endif

        int2 samplePixelCoord = clamp(uv * _TextureSize.zw, 0, _TextureSize.zw - 1);
        float3 color = LOAD_TEXTURE2D_LOD(_InputTexture, samplePixelCoord, 0).rgb;
        float sampledDepth = LoadDepth(samplePixelCoord);
        float linearDepth = GetViewDepthFromDepthTexture(sampledDepth);

        // ------------------------- Accumulate Occlusion Factor -------------------------
            
        bool rangeCheck = abs(sampleHCS.w - linearDepth) < radius; 
        bool occlusion = linearDepth + 0.01 < sampleHCS.w;
        
        if (occlusion && rangeCheck)
        {
            irradiance += color * intensity;
        }
        else
        {
            irradiance += DiffuseGIFallback(sampleWS, normalWS, viewDir) * intensity;
        }
    }
    
    irradiance = saturate(irradiance / sampleCount);
    _OutputTexture[id.xy] = float4(irradiance, originLinearDepth);
    // _OutputTexture[id.xy] = _InputTexture[id.xy];
    // _OutputTexture[id.xy] = float4(normalWS, 0.0);
}
