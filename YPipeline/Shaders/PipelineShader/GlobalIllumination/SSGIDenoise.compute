#pragma kernel TemporalDenoiseKernel

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#include "../../../ShaderLibrary/Core/YPipelineCSCore.hlsl"
#include "DenoiseCommon.hlsl"

// --- Local Textures ---
RWTexture2D<float4> _OutputTexture;
Texture2D<float4> _InputTexture;
Texture2D<float4> _IrradianceHistory;

// --- Global Textures & Samplers ---
TEXTURE2D(_MotionVectorTexture);

SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_PointClamp);

// --- Temporal Filter Groupshared Memory ---
static const uint THREAD_NUM = 8;
static const uint TILE_BORDER = 1;
static const uint TILE_SIZE = THREAD_NUM + 2 * TILE_BORDER;
groupshared float4 _IrradianceZ[TILE_SIZE * TILE_SIZE];

// --- Local Variables ---
float4 _TextureSize; // x: 1.0 / width, y: 1.0 / height, z: width, w: height
float4 _AOTemporalBlurParams; // x: is temporal blur enabled (1 or 0), y: variance critical value

// ----------------------------------------------------------------------------------------------------
// Temporal Filter Functions & Kernel
// ----------------------------------------------------------------------------------------------------

inline void GetNeighbourhoodTileIDs(uint2 middleTileID, inout uint tileIDs[9])
{
    tileIDs[0] = (middleTileID.y     ) * TILE_SIZE + (middleTileID.x     );
    tileIDs[1] = (middleTileID.y +  0) * TILE_SIZE + (middleTileID.x +  1);
    tileIDs[2] = (middleTileID.y +  1) * TILE_SIZE + (middleTileID.x +  0);
    tileIDs[3] = (middleTileID.y +  0) * TILE_SIZE + (middleTileID.x + -1);
    tileIDs[4] = (middleTileID.y + -1) * TILE_SIZE + (middleTileID.x +  0);
    tileIDs[5] = (middleTileID.y +  1) * TILE_SIZE + (middleTileID.x + -1);
    tileIDs[6] = (middleTileID.y +  1) * TILE_SIZE + (middleTileID.x +  1);
    tileIDs[7] = (middleTileID.y + -1) * TILE_SIZE + (middleTileID.x + -1);
    tileIDs[8] = (middleTileID.y + -1) * TILE_SIZE + (middleTileID.x +  1);
}

inline void GetNeighbourhoodSamples(in uint tileIDs[9], inout float4 samples[9])
{
    samples[0] = _IrradianceZ[tileIDs[0]];
    samples[1] = _IrradianceZ[tileIDs[1]];
    samples[2] = _IrradianceZ[tileIDs[2]];
    samples[3] = _IrradianceZ[tileIDs[3]];
    samples[4] = _IrradianceZ[tileIDs[4]];
    samples[5] = _IrradianceZ[tileIDs[5]];
    samples[6] = _IrradianceZ[tileIDs[6]];
    samples[7] = _IrradianceZ[tileIDs[7]];
    samples[8] = _IrradianceZ[tileIDs[8]];
}

[numthreads(THREAD_NUM, THREAD_NUM, 1)]
void TemporalDenoiseKernel(uint3 id : SV_DispatchThreadID, uint3 groupThreadId : SV_GroupThreadID, uint3 groupId : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    // ------------------------- Fetch Irradiance & Depth -------------------------

    int2 tileTopLeftCoord = groupId.xy * THREAD_NUM - TILE_BORDER;

    UNITY_UNROLL
    for (uint i = groupIndex; i < TILE_SIZE * TILE_SIZE; i += THREAD_NUM * THREAD_NUM)
    {
        int2 coord = tileTopLeftCoord + int2(i % TILE_SIZE, i / TILE_SIZE);
        coord = clamp(coord, 0, _TextureSize.zw - 1);
        _IrradianceZ[i] = LoadColorAndDepth(_InputTexture, coord);
    }

    GroupMemoryBarrierWithGroupSync();

    // ------------------------- Reprojection -------------------------
    
    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    float2 velocity = SAMPLE_TEXTURE2D_LOD(_MotionVectorTexture, sampler_PointClamp, screenUV, 0).rg;
    float2 historyUV = screenUV - velocity;
    float4 history = SampleColorAndDepth(_IrradianceHistory, sampler_LinearClamp, historyUV);

    // ------------------------- Fetch Neighbourhood Samples -------------------------
    
    uint2 middleTileID = groupThreadId.xy + TILE_BORDER;
    uint tileIDs[9];
    GetNeighbourhoodTileIDs(middleTileID, tileIDs);
    float4 neighbours[9];
    GetNeighbourhoodSamples(tileIDs, neighbours);

    // ------------------------- History Clamping -------------------------
    
    float3 prefiltered = BilateralFilterMiddleColor(neighbours);
    
    // float gamma = GetTemporalVarianceCriticalValue();
    float gamma = 2.0f;
    float velocityFactor = length(velocity);
    gamma = lerp(gamma, max(gamma - 0.75, 0.1), saturate(velocityFactor * 10));
    float3 minColor, maxColor;
    VarianceMinMax(neighbours, gamma, prefiltered, minColor, maxColor);
    // history.rgb = clamp(history.rgb, minColor, maxColor);
    history.rgb = NeighborhoodClipToFiltered(minColor, maxColor, prefiltered, history.rgb);

    // ------------------------- Adaptive Blending Factor -------------------------
    
    float middleDepth = neighbours[0].a;
    float historyDepth = history.a;
    bool depthTest = abs(1 - middleDepth / historyDepth) < 0.05;
    float blendFactor = lerp(0, 0.95, depthTest); // Depth Test
    blendFactor = lerp(blendFactor, 0, any(abs(historyUV - 0.5) > 0.5)); // Off-Screen Test
    
    _OutputTexture[id.xy] = float4(OutputColor(lerp(prefiltered, history.rgb, blendFactor)), middleDepth);
}
