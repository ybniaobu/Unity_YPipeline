#pragma kernel HBILKernel
#pragma kernel HBILAlternateKernel

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma multi_compile _ _DEFERRED_RENDERING
#pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2

#include "../../../ShaderLibrary/Core/YPipelineCSCore.hlsl"
#include "../../../ShaderLibrary/RandomLibrary.hlsl"
#include "../../../ShaderLibrary/EncodingLibrary.hlsl"
#include "../../../ShaderLibrary/GlobalIllumination/DiffuseGICommon.hlsl"

// --- Local Textures ---
RWTexture2D<float4> _OutputTexture;
Texture2D<float4> _InputTexture;
Texture2D<float4> _IrradianceHistory;

// --- Global Textures & Samplers ---
#ifdef _DEFERRED_RENDERING
TEXTURE2D(_GBuffer1);
#define NORMAL_TEX _GBuffer1
#else
TEXTURE2D(_ThinGBuffer);
#define NORMAL_TEX _ThinGBuffer
#endif

TEXTURE2D(_CameraDepthTexture);
SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_PointClamp);

// --- Global Variables ---
float4 _CameraSettings; // x: vertical FOV in radian, y: cot(FOV/2)
float4 _CameraBufferSize; // x: 1.0 / bufferSize.x, y: 1.0 / bufferSize.y, z: bufferSize.x, w: bufferSize.y
float4 _Jitter; // Halton (-0.5, 0.5), xy: 1.0 / jitter, zw: jitter
float4 _TimeParams; // x: frameCount, y: 1.0 / frameCount

// --- Local Variables ---
float4 _TextureSize; // x: 1.0 / width, y: 1.0 / height, z: width, w: height
float4 _SSGIParams; // x: intensity, y: converge degree, z: direction count, w: step count

TEXTURE2D(_STBN128Scalar3);
float4 _STBN128Scalar3_TexelSize;
TEXTURE2D(_STBN128Vec3);
float4 _STBN128Vec3_TexelSize;
TEXTURE2D(_STBN128UnitVec3);
float4 _STBN128UnitVec3_TexelSize;
TEXTURE2D(_STBN128CosineUnitVec3);
float4 _STBN128CosineUnitVec3_TexelSize;

// ----------------------------------------------------------------------------------------------------
// Input
// ----------------------------------------------------------------------------------------------------

inline float GetIntensity()                 { return _SSGIParams.x; }
inline float GetConvergeDegree()            { return _SSGIParams.y; }
inline float GetDirectionCount()            { return _SSGIParams.z; }
inline float GetStepCount()                 { return _SSGIParams.w; }

// ----------------------------------------------------------------------------------------------------
// Utility Functions
// ----------------------------------------------------------------------------------------------------

inline float LoadDepth(int2 pixelCoord)
{
    return LOAD_TEXTURE2D_LOD(_CameraDepthTexture, pixelCoord, 0).r;
}

float3 FetchPositionVS(float2 screenUV, float rawDepth)
{
    float4 NDC = GetNDCFromUVAndDepth(screenUV, rawDepth);
    float3 VS = TransformNDCToView(NDC, UNITY_MATRIX_I_P);
    VS.z = -VS.z;
    return VS;
}

inline float3 LoadAndDecodeNormal(int2 pixelCoord)
{
    float3 packedNormalWS = LOAD_TEXTURE2D_LOD(NORMAL_TEX, pixelCoord, 0).rgb;
    return DecodeNormalFrom888(packedNormalWS);
}

float3 FetchNormalVS(float3 normalWS)
{
    float3 normalVS = TransformWorldToViewNormal(normalWS, true);
    normalVS.z = -normalVS.z;
    return normalVS;
}

inline float3 LoadRadiance(int2 pixelCoord)
{
    return LOAD_TEXTURE2D_LOD(_InputTexture, pixelCoord, 0).rgb;
}

inline float GTAOFastAcos(float x)
{
    float res = -0.156583 * abs(x) + HALF_PI;
    res *= sqrt(1.0 - abs(x));
    return x >= 0 ? res : PI - res;
}

inline float2 GTAOFastAcos(float2 x)
{
    float2 res = -0.156583 * abs(x) + HALF_PI;
    res *= sqrt(1.0 - abs(x));
    return x >= 0 ? res : PI - res;
}

float2 FetchProjectedNormal2D(float3 normalVS, float3 tangentVS, float3 viewDir)
{
    return float2(dot(normalVS, tangentVS), dot(normalVS, viewDir));
}

float2 InitializeHorizonAngle(float2 projectedNormal2D)
{
    float t = - projectedNormal2D.x / projectedNormal2D.y;
    float cosFront = t * rsqrt(1.0 + t * t);
    return float2(cosFront, -cosFront);
}

// cosTheta 更大的是 θ0，即 cosTheta.x
float3 ComputeNearFieldIrradiance(float2 projectedNormal2D, float2 cosTheta, float3 radiance)
{
    float2 theta = GTAOFastAcos(cosTheta);
    float2 sinTheta2 = 1 - cosTheta * cosTheta;
    float2 sinCosTheta = sqrt(sinTheta2) * cosTheta;
    
    float part0 = projectedNormal2D.x * 0.5 * (theta.y - theta.x + sinCosTheta.x - sinCosTheta.y);
    float part1 = projectedNormal2D.y * 0.5 * (sinTheta2.y - sinTheta2.x);
    
    return radiance * (part0 + part1);
}

float ComputeAOAndBentNormal(float2 projectedNormal2D, float2 maxCosH, out float2 bentNormal)
{
    float2 theta = GTAOFastAcos(maxCosH);
    float2 sinTheta2 = 1 - maxCosH * maxCosH;
    float2 sinCosTheta = sqrt(sinTheta2) * maxCosH;
    
    float part0 = 0.5 * (theta.y + theta.x - sinCosTheta.x - sinCosTheta.y);
    float part1 = 0.5 * (sinTheta2.y + sinTheta2.x);
    bentNormal = float2(part0, part1);
    
    return projectedNormal2D.x * part0 + projectedNormal2D.y * part1;
}

// ----------------------------------------------------------------------------------------------------
// HBIL Kernel
// ----------------------------------------------------------------------------------------------------

[numthreads(8, 8, 1)]
void HBILKernel(uint3 id : SV_DispatchThreadID)
{
    int2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    float2 screenUV = (float2(pixelCoord) + float2(0.5, 0.5)) * _TextureSize.xy;
    
    // ------------------------- Fetch Position & Normal -------------------------
    
    float rawDepth = LoadDepth(pixelCoord);
    
    // TODO: 待修改
    float4 originNDC = GetNDCFromUVAndDepth(screenUV, rawDepth);
    float3 originWS = TransformNDCToWorld(originNDC, UNITY_MATRIX_I_VP);
    float3 viewDirWS = GetWorldSpaceNormalizedViewDir(originWS);
    
    float3 positionVS = FetchPositionVS(screenUV, rawDepth);
    float3 viewDir = normalize(-positionVS);

    float3 normalWS = LoadAndDecodeNormal(pixelCoord);
    float3 normalVS = FetchNormalVS(normalWS);
    
    // ------------------------- Calculate Radius & Step Size -------------------------
    
    float radiusInUV = 0.5 * GetConvergeDegree() * _CameraSettings.y / positionVS.z;
    // float radiusInPixel = min(radiusInUV * _TextureSize.w, 0.2 * _TextureSize.w);
    float radiusInPixel = radiusInUV * _TextureSize.w;

    if (radiusInPixel < 1 || rawDepth < 1e-7)
    {
        _OutputTexture[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // ------------------------- Calculate Step Size -------------------------

    // Avoid oversampling if numSteps is greater than the kernel radius in pixels
    float numSteps = min(GetStepCount(), radiusInPixel);
    float stepSizeInPixel = radiusInPixel / numSteps;
    
    // ------------------------- Noise -------------------------
    
    float2 noise = LOAD_TEXTURE2D_LOD(_STBN128Scalar3, id.xy % _STBN128Scalar3_TexelSize.zw, 0).rg;
    // float randomRadian = (noise.r + _Jitter.z * IsTemporalBlurEnabled()) * TWO_PI;
    float randomRadian = (noise.r + _Jitter.z) * TWO_PI;
    // float randomOffset = frac(noise.g + _Jitter.w * IsTemporalBlurEnabled());
    float randomOffset = noise.g;
    
    // ------------------------- Loop -------------------------

    float3 irradiance = 0;
    float3 bentNormalVS = 0;
    float ao = 0;
    float dirAngle = PI / GetDirectionCount();
    float r2 = GetConvergeDegree() * GetConvergeDegree();
    
    for (int d = 0; d < GetDirectionCount(); d++)
    {
        // ------------------------- Randomize Direction -------------------------
        
        float angle = dirAngle * d + randomRadian;
        float3 sliceDir = float3(cos(angle), sin(angle), 0);
        float2 pixelDelta = sliceDir.xy * stepSizeInPixel;
        
        // ------------------------- Normal Projection -------------------------
        
        float3 sliceNormal = normalize(cross(sliceDir, viewDir));
        float3 tangentVS = normalize(cross(viewDir, sliceNormal)); // D(φ)
        // float3 realTangentVS = cross(normalVS, sliceNormal);
        // float3 projectedNormal = normalVS - sliceNormal * dot(normalVS, sliceNormal);
        float2 projectedNormal2D = FetchProjectedNormal2D(normalVS, tangentVS, viewDir); // n'
        float2 maxCosH = InitializeHorizonAngle(projectedNormal2D);
        
        for (int s = 0; s < GetStepCount(); s++)
        {
            float2 offset = (randomOffset + s) * pixelDelta;
            float4 sampleCoord = clamp(id.xyxy + float4(-offset, offset), 0, _TextureSize.zwzw - 1);
            float4 sampleUV = (sampleCoord + 0.5) * _TextureSize.xyxy;
            float sh1Depth = LoadDepth(sampleCoord.xy);
            float sh2Depth = LoadDepth(sampleCoord.zw);
            float3 sh1 = FetchPositionVS(sampleUV.xy, sh1Depth) - positionVS; // H1
            float3 sh2 = FetchPositionVS(sampleUV.zw, sh2Depth) - positionVS; // H2
            float2 length2 = float2(dot(sh1, sh1), dot(sh2, sh2));
            float2 cosH = float2(dot(sh1, viewDir), dot(sh2, viewDir)) * rsqrt(length2);
            
            if (length2.x < r2 && cosH.x > maxCosH.x)
            {
                float3 nearRadiance = LoadRadiance(sampleCoord.xy);
                float2 cosTheta = float2(cosH.x, maxCosH.x);
                irradiance += ComputeNearFieldIrradiance(projectedNormal2D, cosTheta, nearRadiance);
                maxCosH.x = cosH.x;
            }
            
            if (length2.y < r2 && cosH.y > maxCosH.y)
            {
                float3 nearRadiance = LoadRadiance(sampleCoord.zw);
                float2 cosTheta = float2(cosH.y, maxCosH.y);
                irradiance += ComputeNearFieldIrradiance(projectedNormal2D, cosTheta, nearRadiance);
                maxCosH.y = cosH.y;
            }
        }
        
        float2 bentNormal2D;
        ao += ComputeAOAndBentNormal(projectedNormal2D, maxCosH, bentNormal2D);
        
        bentNormalVS += bentNormal2D.x * tangentVS + bentNormal2D.y * viewDir;
    }
    
    ao = saturate(ao / GetDirectionCount());
    bentNormalVS.z = -bentNormalVS.z;
    float3 bentNormal = TransformViewToWorldDir(bentNormalVS / GetDirectionCount(), true);
    
    
    irradiance = irradiance / GetDirectionCount();
    // irradiance += DiffuseGIFallback(originWS, normalWS, viewDirWS);
    _OutputTexture[id.xy] = float4(irradiance, 0.0);
}

// ----------------------------------------------------------------------------------------------------
// HBIL Kernel (Alternate)
// 上面的代码使用的是 HBIL 论文中的方法，下面使用的是 GTAO 中的方法。
// GTAO 的方法比 HBIL 论文中的逻辑更加直接，但是性能更差，可以用于佐证上面的代码有没有写对。
// ----------------------------------------------------------------------------------------------------

// 注意 h.x 是 h1 应该为负数，h.y 是 h2 应该为正数
float IntegrateArcAO(float2 h, float n)
{
    float2 arc = -cos(2 * h - n) + cos(n) + 2 * h * sin(n);
    return 0.25 * (arc.x + arc.y);
}

float IntegrateArcIrradiance(float2 theta, float n)
{
    float2 arc = -cos(2 * theta - n) + 2 * theta * sin(n);
    return 0.25 * (arc.y - arc.x);
}

float3 SliceMarching(bool IsRightDir, uint2 pixelCoord, float2 maxTexelDelta, float randomOffset, float3 positionVS, float3 viewDir, float n, float projectedNormalLength, inout float2 maxCosH)
{
    float3 irradiance = 0;
    float samplingDirection = lerp(-1.0, 1.0, IsRightDir);
    float max = lerp(maxCosH.x, maxCosH.y, IsRightDir);
    
    for (int s = 0; s < GetStepCount(); s++)
    {
        float2 offset = PositivePow((randomOffset + s) / GetStepCount(), GetConvergeDegree()) * maxTexelDelta;
        int2 sampleCoord = pixelCoord + offset * samplingDirection;
        sampleCoord = clamp(sampleCoord, 0, _TextureSize.zw - 1);
        float2 sampleUV = (float2(sampleCoord) + 0.5) * _TextureSize.xy;

        // ------------------------- Calculate CosH -------------------------
        
        float sampleDepth = LoadDepth(sampleCoord);
        float3 H = normalize(FetchPositionVS(sampleUV.xy, sampleDepth) - positionVS);
        float cosH = dot(H, viewDir);
            
        // ------------------------- Irradiance Integral -------------------------
        
        if (cosH > max)
        {
            float3 nearRadiance = LoadRadiance(sampleCoord);
            float2 cosTheta = float2(cosH, max);
            float2 theta = GTAOFastAcos(cosTheta) * samplingDirection;
            irradiance += projectedNormalLength * IntegrateArcIrradiance(theta, n) * nearRadiance;
            max = cosH;
        }
        
        // 当样本离屏时，停止采样，但确保采样过一次。
        if (sampleCoord.x == 0 || sampleCoord.y == 0 || sampleCoord.x == _TextureSize.z - 1 || sampleCoord.y == _TextureSize.w - 1) break;
    }
    
    maxCosH = IsRightDir ? float2(maxCosH.x, max) : float2(max, maxCosH.y);
    return irradiance;
}

[numthreads(8, 8, 1)]
void HBILAlternateKernel(uint3 id : SV_DispatchThreadID)
{
    int2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    float2 screenUV = (float2(pixelCoord) + float2(0.5, 0.5)) * _TextureSize.xy;

    // ------------------------- Fetch Position & Normal -------------------------
    
    float rawDepth = LoadDepth(pixelCoord);
    float3 positionVS = FetchPositionVS(screenUV, rawDepth);
    float3 viewDir = normalize(-positionVS);
    
    if (rawDepth < 1e-7)
    {
        _OutputTexture[id.xy] = float4(0.0, 0.0, 0.0, positionVS.z);
        return;
    }

    float3 normalWS = LoadAndDecodeNormal(pixelCoord);
    float3 normalVS = FetchNormalVS(normalWS);
    
    // TODO: 与 APV 采样有关，待修改
    float3 positionWS = TransformViewToWorld(float3(positionVS.xy, -positionVS.z));
    float3 viewDirWS = GetWorldSpaceNormalizedViewDir(positionWS);

    // ------------------------- Noise -------------------------
    
    float2 frameMagicScale = k_Halton[_TimeParams.x % 64 + 1];
    int2 sampleCoord = (pixelCoord + _TimeParams.x * frameMagicScale) % _STBN128Scalar3_TexelSize.zw;
    float3 noise = LOAD_TEXTURE2D_LOD(_STBN128Scalar3, sampleCoord, 0).rgb;
    float randomRadian = noise.r * TWO_PI;
    float randomOffset = noise.b;
    
    // float3 noise = LOAD_TEXTURE2D_LOD(_STBN128Scalar3, pixelCoord % _STBN128Scalar3_TexelSize.zw, 0).rgb;
    // float randomRadian = (noise.r + _Jitter.z * IsTemporalBlurEnabled()) * TWO_PI;
    // float randomOffset = frac(noise.g + _Jitter.w * IsTemporalBlurEnabled());
    
    // ------------------------- Direction Loop -------------------------
    
    int maxRayTexel = max(_TextureSize.z, _TextureSize.w);
    float dirAngle = PI / GetDirectionCount();
    float3 irradiance = 0;
    float3 bentNormalVS = 0;
    
    for (int d = 0; d < GetDirectionCount(); d++)
    {
        // ------------------------- Randomize Direction -------------------------
        
        float angle = dirAngle * d + randomRadian;
        float3 sliceDir = float3(cos(angle), sin(angle), 0);
        float2 maxTexelDelta = sliceDir.xy * maxRayTexel;
        
        // ------------------------- Normal Projection & Initialize Horizon Angle -------------------------
        
        float3 sliceNormal = normalize(cross(sliceDir, viewDir));
        float3 realTangent = cross(normalVS, sliceNormal);
        float3 projectedNormal = normalVS - sliceNormal * dot(normalVS, sliceNormal);
        float projectedNormalLength = length(projectedNormal);
        
        float cosH_InitialValue = dot(viewDir, realTangent);
        float cosN = clamp(dot(projectedNormal / projectedNormalLength, viewDir), -1.0, 1.0);
        float n = -sign(cosH_InitialValue) * GTAOFastAcos(cosN);
        float2 maxCosH = float2(-cosH_InitialValue, cosH_InitialValue);
        
        // ------------------------- Marching -------------------------
        
        irradiance += SliceMarching(true, id.xy, maxTexelDelta, randomOffset, positionVS, viewDir, n, projectedNormalLength, maxCosH);
        irradiance += SliceMarching(false, id.xy, maxTexelDelta, randomOffset, positionVS, viewDir, n, projectedNormalLength, maxCosH);
        
        // ------------------------- Bent Normal -------------------------
        
        float2 h = GTAOFastAcos(maxCosH);
        h.x = -h.x;
        float bentAngle = (h.x + h.y) * 0.5;
        float3 tangentVS = cross(viewDir, sliceNormal);
        bentNormalVS += viewDir * cos(bentAngle) + tangentVS * sin(bentAngle);
    }
    
    bentNormalVS = normalize(bentNormalVS);
    bentNormalVS.z = -bentNormalVS.z;
    
    float3 bentNormal = TransformViewToWorldDir(bentNormalVS,true);
    
    irradiance = irradiance / GetDirectionCount() * GetIntensity();
    irradiance += DiffuseGIFallback(positionWS, normalWS, bentNormal, noise);
    _OutputTexture[id.xy] = float4(irradiance, positionVS.z);
}