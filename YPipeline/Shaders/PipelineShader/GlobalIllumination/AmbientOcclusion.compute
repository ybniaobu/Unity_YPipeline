#pragma kernel SSAOKernel
#pragma kernel GTAOKernel
#pragma kernel DepthDownsampleKernel
#pragma kernel UpsampleKernel
#pragma kernel SpatialBlurHorizontalKernel
#pragma kernel SpatialBlurVerticalKernel
#pragma kernel TemporalBlurKernel

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma multi_compile _ _HALF_RESOLUTION

#include "../../../ShaderLibrary/Core/YPipelineCSCore.hlsl"
#include "../../../ShaderLibrary/RandomLibrary.hlsl"
#include "../../../ShaderLibrary/EncodingLibrary.hlsl"

// --- Local Textures ---
RWTexture2D<float2> _OutputTexture;
Texture2D<float2> _InputTexture;
Texture2D<float> _HalfDepthTexture;
Texture2D<float2> _AmbientOcclusionHistory;

// --- Global Textures & Samplers ---
TEXTURE2D(_ThinGBuffer);
TEXTURE2D(_CameraDepthTexture);
TEXTURE2D(_MotionVectorTexture);
TEXTURE2D(_BlueNoise64);
float4 _BlueNoise64_TexelSize;
SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_PointClamp);

// --- Global Variables ---
float4 _CameraSettings; // x: vertical FOV in radian, y: cot(FOV/2)
float4 _CameraBufferSize; // x: 1.0 / bufferSize.x, y: 1.0 / bufferSize.y, z: bufferSize.x, w: bufferSize.y
float4 _Jitter; // Halton (-0.5, 0.5), xy: 1.0 / jitter, zw: jitter

// --- Local Variables ---
float4 _TextureSize; // x: 1.0 / width, y: 1.0 / height, z: width, w: height

// SSAO - x: intensity, y: sample count, z: radius
// HBAO - x: intensity, y: radius, z: direction count, w: step count
// GTAO - x: intensity, y: radius, z: direction count, w: step count
float4 _AmbientOcclusionParams;
float4 _AOSpatialBlurParams; // x: kernel radius, y: spatial sigma, z: depth/range sigma
float4 _AOTemporalBlurParams; // x: is temporal blur enabled (1 or 0), y: variance critical value

// --- Spatial Filter Groupshared Memory ---
#define MAX_FILTER_RADIUS 8
groupshared float2 _AOAndDepth[64 + 2 * MAX_FILTER_RADIUS];

// --- Temporal Filter Groupshared Memory ---
static const uint THREAD_NUM = 8;
static const uint TILE_BORDER = 1;
static const uint TILE_SIZE = THREAD_NUM + 2 * TILE_BORDER;
groupshared float2 _AOZ[TILE_SIZE * TILE_SIZE];

// ----------------------------------------------------------------------------------------------------
// Input
// ----------------------------------------------------------------------------------------------------

inline float GetSSAOIntensity()                 { return _AmbientOcclusionParams.x; }
inline float GetSSAOSampleCount()               { return _AmbientOcclusionParams.y; }
inline float GetSSAORadius()                    { return _AmbientOcclusionParams.z; }

inline float GetHBAOIntensity()                 { return _AmbientOcclusionParams.x; }
inline float GetHBAORadius()                    { return _AmbientOcclusionParams.y; }
inline float GetHBAODirectionCount()            { return _AmbientOcclusionParams.z; }
inline float GetHBAOStepCount()                 { return _AmbientOcclusionParams.w; }

inline float GetGTAOIntensity()                 { return _AmbientOcclusionParams.x; }
inline float GetGTAORadius()                    { return _AmbientOcclusionParams.y; }
inline float GetGTAODirectionCount()            { return _AmbientOcclusionParams.z; }
inline float GetGTAOStepCount()                 { return _AmbientOcclusionParams.w; }

inline float GetSpatialBlurKernelRadius()       { return _AOSpatialBlurParams.x; }
inline float2 GetSpatialBlurSigma()             { return _AOSpatialBlurParams.yz; }
inline float IsTemporalBlurEnabled()            { return _AOTemporalBlurParams.x; }
inline float GetTemporalVarianceCriticalValue() { return _AOTemporalBlurParams.y; }

#include "AmbientOcclusionDenoise.hlsl"

// ----------------------------------------------------------------------------------------------------
// SSAO Utility Functions
// ----------------------------------------------------------------------------------------------------

float LoadDepth(int2 pixelCoord)
{
    #ifdef _HALF_RESOLUTION
    return LOAD_TEXTURE2D_LOD(_HalfDepthTexture, pixelCoord, 0).r;
    #else
    return LOAD_TEXTURE2D_LOD(_CameraDepthTexture, pixelCoord, 0).r;
    #endif
}

float3 LoadAndDecodeNormal(int2 pixelCoord)
{
    #ifdef _HALF_RESOLUTION
    float3 packedNormalWS = LOAD_TEXTURE2D_LOD(_ThinGBuffer, pixelCoord * 2, 0).rgb;
    #else
    float3 packedNormalWS = LOAD_TEXTURE2D_LOD(_ThinGBuffer, pixelCoord, 0).rgb;
    #endif
    
    return DecodeNormalFrom888(packedNormalWS);
}

// ----------------------------------------------------------------------------------------------------
// SSAO Functions & Kernel
// ----------------------------------------------------------------------------------------------------

// Left-handed Spherical and Cartesian Coordinate, Coordinate Convention Detail see SamplingLibrary.hlsl

float3 GenerateHemisphereSamples(float2 xi, float scale)
{
    float phi = PI * (2.0 * xi.x - 1.0);
    float cosTheta = 1 - xi.y;
    float sinTheta = sqrt(1 - cosTheta * cosTheta);
    
    float r = scale * scale; // distribute more samples closer to the hemisphere origin
    return float3(r * sinTheta * cos(phi), r * cosTheta, r * sinTheta * sin(phi));
}

float3 GenerateCosineWeightedHemisphereSamples(float2 xi, float scale)
{
    float phi = PI * (2.0 * xi.x - 1.0);
    float cosTheta = sqrt(1 - xi.y);
    float sinTheta = sqrt(1 - cosTheta * cosTheta);
    
    float r = scale * scale; // distribute more samples closer to the hemisphere origin
    return float3(r * sinTheta * cos(phi), r * cosTheta, r * sinTheta * sin(phi));
}

[numthreads(8, 8, 1)]
void SSAOKernel(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    float2 screenUV = (float2(pixelCoord) + float2(0.5, 0.5)) * _TextureSize.xy;
    
    // ------------------------- Get Origin Position -------------------------
    
    float originDepth = LoadDepth(pixelCoord);
    float originLinearDepth = GetViewDepthFromDepthTexture(originDepth);
    float4 originNDC = GetNDCFromUVAndDepth(screenUV, originDepth);
    float3 originWS = TransformNDCToWorld(originNDC, UNITY_MATRIX_I_VP);

    if (originDepth < 1e-7)
    {
        _OutputTexture[id.xy] = float2(1.0, originLinearDepth);
        return;
    }

    // ------------------------- Get Normal & Build Left-Handed TBN -------------------------
    
    float3 normalWS = LoadAndDecodeNormal(pixelCoord); // N

    float3 up = abs(normalWS.y) > 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);
    float3 tangent = normalize(cross(up, normalWS)); // T
    float3 binormal = normalize(cross(tangent, normalWS)); // B

    // ------------------------- Random Rotation -------------------------
    
    float randomRadian = (LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.zw, 0).r + _Jitter.z * IsTemporalBlurEnabled()) * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));

    // ------------------------- SSAO Loop -------------------------
    
    float aoFactor = 0.0;
    float intensity = GetSSAOIntensity();
    float sampleCount = GetSSAOSampleCount();
    float radius = GetSSAORadius();

    UNITY_UNROLL
    for (int i = 0; i < sampleCount; i++)
    {
        // ------------------------- Generate Hemisphere Samples -------------------------
        
        float2 xi = k_Sobol[i + 1];
        float scale = max(k_Halton[i + 1].y + _Jitter.z * 0.01 * IsTemporalBlurEnabled(), 0.01);
        float3 dirTS = GenerateCosineWeightedHemisphereSamples(xi, scale);
        dirTS.xz = mul(rotation, dirTS.xz);

        // ------------------------- Sample Depth Buffer -------------------------
        
        float3 dirWS = tangent * dirTS.x + normalWS * dirTS.y + binormal * dirTS.z;
        float3 sampleWS = originWS + dirWS * radius;
        float4 sampleHCS = TransformWorldToHClip(sampleWS);
        sampleHCS.xyz /= sampleHCS.w;
        float2 uv = sampleHCS.xy * 0.5 + 0.5;

        #if UNITY_UV_STARTS_AT_TOP
        uv.y = 1.0f - uv.y;
        #endif

        int2 samplePixelCoord = clamp(uv * _TextureSize.zw, 0, _TextureSize.zw - 1);
        float sampledDepth = LoadDepth(samplePixelCoord);
        float linearDepth = GetViewDepthFromDepthTexture(sampledDepth);

        // ------------------------- Accumulate Occlusion Factor -------------------------
        
        bool rangeCheck = abs(sampleHCS.w - linearDepth) < radius;
        float occlusion = (linearDepth + 0.01 < sampleHCS.w) * rangeCheck * intensity;
        aoFactor += 1.0 - occlusion;
    }
    
    aoFactor = saturate(aoFactor / sampleCount);
    _OutputTexture[id.xy] = float2(aoFactor, originLinearDepth);
}

// ----------------------------------------------------------------------------------------------------
// GTAO Functions & Kernel
// ----------------------------------------------------------------------------------------------------

#define GTAO_NUM_DIRECTIONS GetGTAODirectionCount() 
#define GTAO_NUM_STEPS GetGTAOStepCount()

float3 FetchViewPosition(float2 screenUV, float rawDepth)
{
    float4 NDC = GetNDCFromUVAndDepth(screenUV, rawDepth);
    float3 VS = TransformNDCToView(NDC, UNITY_MATRIX_I_P);
    VS.z = -VS.z;
    return VS;
}

float3 FetchViewNormal(float3 normalWS)
{
    float3 normalVS = TransformWorldToViewNormal(normalWS, true);
    normalVS.z = -normalVS.z;
    return normalVS;
}

float IntegrateArcUniformWeight(float2 h)
{
    float2 arc = 1 - cos(h);
    return arc.x + arc.y;
}

float IntegrateArcCosWeight(float2 h, float n)
{
    float2 arc = -cos(2 * h - n) + cos(n) + 2 * h * sin(n);
    return 0.25 * (arc.x + arc.y);
}

[numthreads(8, 8, 1)]
void GTAOKernel(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    float2 screenUV = (float2(pixelCoord) + float2(0.5, 0.5)) * _TextureSize.xy;

    // ------------------------- Fetch Position & Normal -------------------------
    
    float rawDepth = LoadDepth(pixelCoord);
    float3 P = FetchViewPosition(screenUV, rawDepth);
    float3 V = normalize(-P);

    float3 normalWS = LoadAndDecodeNormal(pixelCoord);
    float3 normalVS = FetchViewNormal(normalWS);

    // ------------------------- Calculate Radius & Step Size -------------------------
    
    float radiusInUV = 0.5 * GetGTAORadius() * _CameraSettings.y / P.z;
    float radiusInPixel = radiusInUV * _TextureSize.w;

    if (radiusInPixel < 1 || rawDepth < 1e-7)
    {
        _OutputTexture[id.xy] = float2(1.0, P.z);
        return;
    }

    // ------------------------- Calculate Step Size -------------------------

    // Avoid oversampling if NUM_STEPS is greater than the kernel radius in pixels
    float numSteps = min(GTAO_NUM_STEPS, radiusInPixel);
    float stepSizeInPixel = radiusInPixel / numSteps;

    // ------------------------- Direction Loop -------------------------

    float noise = LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.zw, 0).r;
    float randomRadian = (noise + _Jitter.w * IsTemporalBlurEnabled()) * TWO_PI;
    float dirAngle = PI / GTAO_NUM_DIRECTIONS;
    float ao = 0;
    
    for (int d = 0; d < GTAO_NUM_DIRECTIONS; d++)
    {
        // ------------------------- Randomize Direction -------------------------
        
        float angle = dirAngle * d + randomRadian;
        float3 dir = float3(cos(angle), sin(angle), 0);
        float2 pixelDelta = dir.xy * stepSizeInPixel;

        // ------------------------- Slice Loop -------------------------
        
        float2 cosH;
        float2 heuristicCosH = 0;
        float2 count;
        float2 lastCosH = -1.0;

        float rand = (d + 1.0 + _Jitter.z * IsTemporalBlurEnabled()) / ( GTAO_NUM_DIRECTIONS + 1.0);
        
        for (int s = 0; s < numSteps; s++)
        {
            // ------------------------- Apply Random Offset -------------------------
            
            float2 offset = (rand + s) * pixelDelta;
            float4 sampleCoord = clamp(id.xyxy + float4(-offset, offset), 0, _TextureSize.zwzw - 1);

            float4 sampleUV = (sampleCoord + 0.5) * _TextureSize.xyxy;
            float sh1Depth = LoadDepth(sampleCoord.xy);
            float sh2Depth = LoadDepth(sampleCoord.zw);
            float3 sh1 = FetchViewPosition(sampleUV.xy, sh1Depth) - P; // H1
            float3 sh2 = FetchViewPosition(sampleUV.zw, sh2Depth) - P; // H2
            float2 length2 = float2(dot(sh1, sh1), dot(sh2, sh2));

            float2 falloff = (length2 / GetGTAORadius() / GetGTAORadius());
            cosH = float2(dot(sh1, V), dot(sh2, V)) * rsqrt(length2);

            // cosH.x = falloff.x < 1 ? cosH.x : heuristicCosH.x;
            // cosH.y = falloff.y < 1 ? cosH.y : heuristicCosH.y;
            //
            // heuristicCosH.x = cosH.x < heuristicCosH.x ? 0.75 * heuristicCosH.x + 0.25 * cosH.x : cosH.x;
            // heuristicCosH.y = cosH.y < heuristicCosH.y ? 0.75 * heuristicCosH.y + 0.25 * cosH.y : cosH.y;
            // heuristicCosH = max(cosH, lastCosH);

            // ------------------------- 算术平均 -------------------------
            // cosH = lerp(cosH, 0, falloff < 1);
            cosH.x = falloff.x < 1 ? cosH.x : 0;
            cosH.y = falloff.y < 1 ? cosH.y : 0;
            count.x += falloff.x < 1 ? 1 : 0;
            count.y += falloff.y < 1 ? 1 : 0;
            heuristicCosH += cosH;
            // ------------------------- 算术平均 -------------------------


            // heuristicCosH = max(cosH, lastCosH);
            lastCosH = cosH;
        }

        // ------------------------- 算术平均 -------------------------
        // heuristicCosH /= count;
        heuristicCosH.x = count.x == 0 ? -1 : heuristicCosH.x / count.x;
        heuristicCosH.y = count.y == 0 ? -1 : heuristicCosH.y / count.y;
        heuristicCosH = clamp(heuristicCosH, -1.0, 1.0);
        // ------------------------- 算术平均 -------------------------

        float3 sliceNormal = normalize(cross(dir, V));
        float3 tangent = cross(normalVS, sliceNormal);
        float3 projectedNormal = normalVS - sliceNormal * dot(normalVS, sliceNormal);
        float projectedNormalLength = length(projectedNormal);

        float cosn = dot(normalize(projectedNormal), V);
        float n = -sign(dot(V, tangent)) * acos(cosn);

        float2 h = acos(heuristicCosH);
        h.x = n + max(-h.x - n, -HALF_PI); // H1
        h.y = n + min(h.y - n, HALF_PI); // H2

        ao += projectedNormalLength * IntegrateArcCosWeight(h, n);
    }

    ao = saturate(PositivePow(ao / GTAO_NUM_DIRECTIONS, GetGTAOIntensity()));
    _OutputTexture[id.xy] = float2(ao, P.z);
}

// ----------------------------------------------------------------------------------------------------
// HBAO Functions & Kernel (Deprecated 不推荐使用)
// Modified from: NVIDIA-Direct3D-SDK-11/SSAO11/NVSDK_D3D11_SSAO
// ----------------------------------------------------------------------------------------------------

#define HBAO_NUM_DIRECTIONS GetHBAODirectionCount()
#define HBAO_NUM_STEPS GetHBAOStepCount()

inline float Falloff(float d2, float r2)
{
    return saturate(1.0 - d2 * rcp(r2));
}

[numthreads(8, 8, 1)]
void HBAOKernel(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    float2 screenUV = (float2(pixelCoord) + float2(0.5, 0.5)) * _TextureSize.xy;

    // ------------------------- Fetch Position & Normal -------------------------
    
    float rawDepth = LoadDepth(pixelCoord);
    float3 P = FetchViewPosition(screenUV, rawDepth);
    float3 V = normalize(-P);

    float3 normalWS = LoadAndDecodeNormal(pixelCoord);
    float3 normalVS = FetchViewNormal(normalWS);

    // ------------------------- Calculate Radius -------------------------

    float radiusInUV = 0.5 * GetHBAORadius() * _CameraSettings.y / P.z;
    float radiusInPixel = radiusInUV * _TextureSize.w;
    
    if (radiusInPixel < 1 || rawDepth < 1e-7)
    {
        _OutputTexture[id.xy] = float2(1.0, P.z);
        return;
    }

    // ------------------------- Calculate Step Size -------------------------

    // Avoid oversampling if NUM_STEPS is greater than the kernel radius in pixels
    float numSteps = min(HBAO_NUM_STEPS, radiusInPixel);
    float stepSizeInPixel = radiusInPixel / numSteps;
    
    // ------------------------- HBAO Loop -------------------------
    
    float ao = 0;
    float dirAngle = TWO_PI / HBAO_NUM_DIRECTIONS;
    float noise = LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.zw, 0).r;
    float randomRadian = (noise + _Jitter.w * IsTemporalBlurEnabled()) * TWO_PI;
    
    for (int d = 0; d < HBAO_NUM_DIRECTIONS; ++d)
    {
        // ------------------------- Randomize Direction -------------------------
        
        float angle = dirAngle * d + randomRadian;
        float2 dir = float2(cos(angle), sin(angle));
        float2 pixelDelta = dir * stepSizeInPixel;

        // ------------------------- Apply Random Offset -------------------------
        
        float rand = (d + 1.0 + _Jitter.w * IsTemporalBlurEnabled()) / (HBAO_NUM_DIRECTIONS + 1.0);
        float2 sampleCoord = id.xy + rand * pixelDelta;

        // ------------------------- Calculate SinT -------------------------
        
        float3 sliceNormal = normalize(cross(float3(dir, 0), V));
        float3 T = normalize(cross(normalVS, sliceNormal));
        float sinT = -T.z;
        float lastSinH = sinT;

        float r2 = GetHBAORadius() * GetHBAORadius();
        
        for (float j = 0; j < numSteps; ++j)
        {
            // ------------------------- Fetch Sample Position -------------------------
            
            sampleCoord = clamp(sampleCoord, 0, _TextureSize.zw - 1);
            float2 sampleUV = (sampleCoord + 0.5) * _TextureSize.xy;
            float sDepth = LoadDepth(sampleCoord);
            float3 S = FetchViewPosition(sampleUV, sDepth);
            float d2 = Length2(S - P);

            // ------------------------- Calculate SinH -------------------------
            
            float3 H = (S - P) * rsqrt(d2);
            float sinH = -H.z;

            // ------------------------- Per-Sample Attenuation -------------------------
            
            [branch]
            if (d2 < r2 && sinH > lastSinH)
            {
                ao += Falloff(d2, r2) * (sinH - lastSinH);
                lastSinH = sinH;
            }
        
            sampleCoord += pixelDelta;
        }
    }

    ao = saturate(1 - ao * rcp(HBAO_NUM_DIRECTIONS) * GetHBAOIntensity());
    _OutputTexture[id.xy] = float2(ao, P.z);
}