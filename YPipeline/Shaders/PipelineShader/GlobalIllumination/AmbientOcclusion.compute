#pragma kernel SSAOKernel
#pragma kernel SpatialBlurHorizontalKernel
#pragma kernel SpatialBlurVerticalKernel
#pragma kernel TemporalBlurKernel

#define THREAD_NUM_X 8
#define THREAD_NUM_Y 8

#include "../../../ShaderLibrary/Core/YPipelineCSCore.hlsl"
#include "../../../ShaderLibrary/RandomLibrary.hlsl"
#include "../../../ShaderLibrary/SamplingLibrary.hlsl"
#include "../../../ShaderLibrary/EncodingLibrary.hlsl"

#include "../../../ShaderLibrary/GlobalIllumination/SSAO.hlsl"

RWTexture2D<float2> _OutputTexture;
Texture2D<float2> _InputTexture;
Texture2D<float2> _AmbientOcclusionHistory;

TEXTURE2D(_ThinGBuffer);
TEXTURE2D(_CameraDepthTexture);
TEXTURE2D(_MotionVectorTexture);
TEXTURE2D(_BlueNoise64);
float4 _BlueNoise64_TexelSize;
SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_PointClamp);

float4 _CameraBufferSize; // x: 1.0 / bufferSize.x, y: 1.0 / bufferSize.y, z: bufferSize.x, w: bufferSize.y
float4 _Jitter; // Halton (-0.5, 0.5), xy: 1.0 / jitter, zw: jitter

float4 _TextureSize; // x: 1.0 / width, y: 1.0 / height, z: width, w: height

// SSAO - x: intensity, y: sample count, z: radius, w: reflection rate
// HBAO - x: , y: , z: , w:
// GTAO - x: , y: , z: , w: 
float4 _AmbientOcclusionParams;
float4 _AOBlurParams; // x: kernel radius, y: spatial sigma, z: depth/range sigma, w: temporal blend factor

// ----------------------------------------------------------------------------------------------------
// Input
// ----------------------------------------------------------------------------------------------------

inline float GetSSAOIntensity()             { return _AmbientOcclusionParams.x; }
inline float GetSSAOSampleCount()           { return _AmbientOcclusionParams.y; }
inline float GetSSAORadius()                { return _AmbientOcclusionParams.z; }
inline float GetSSAOReflectionRate()        { return _AmbientOcclusionParams.w; }
inline float GetSpatialBlurKernelRadius()   { return _AOBlurParams.x; }
inline float GetSpatialBlurSpatialSigma()   { return _AOBlurParams.y; }
inline float GetSpatialBlurDepthSigma()     { return _AOBlurParams.z; }

// ----------------------------------------------------------------------------------------------------
// AO Kernels
// ----------------------------------------------------------------------------------------------------

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void SSAOKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;

    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    
    // ------------------------- Get Depth -------------------------

    float4 depths = GATHER_RED_TEXTURE2D(_CameraDepthTexture, sampler_PointClamp, screenUV);
    // float originDepth = Min3(depths.x, depths.y, min(depths.z, depths.w));
    
    float originDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_LinearClamp, screenUV, 0).r;
    float4 originNDC = GetNDCFromUVAndDepth(screenUV, originDepth);
    float3 originWS = TransformNDCToWorld(originNDC, UNITY_MATRIX_I_VP);

    // ------------------------- Get Normal & Build Left-Handed TBN -------------------------
    
    float3 packedNormalWS = SAMPLE_TEXTURE2D_LOD(_ThinGBuffer, sampler_PointClamp, screenUV, 0).rgb;
    float3 normalWS = DecodeNormalFrom888(packedNormalWS); // N

    float3 up = abs(normalWS.y) > 0.999999 ? float3(0, 0, 1) : float3(0, 1, 0);
    float3 tangent = normalize(cross(up, normalWS)); // T
    float3 binormal = normalize(cross(tangent, normalWS)); // B

    // ------------------------- Generate Normal-Oriented Hemisphere Samples -------------------------

    // TODO: Temporal Filter
    // float randomRadian = (LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.w, 0).r) * TWO_PI;
    float randomRadian = (LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.w, 0).r + _Jitter.w) * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));

    // GroupMemoryBarrierWithGroupSync();
    
    float aoFactor = 0.0;
    float intensity = GetSSAOIntensity();
    float sampleCount = GetSSAOSampleCount();
    float radius = GetSSAORadius();
    float weightSum = 0.0;

    UNITY_UNROLL
    for (int i = 0; i < sampleCount; i++)
    {
        float2 xi = k_Halton[i + 1];
        // float3 xi = k_Halton3D[i + 1];
        // float3 xi = float3(k_SobolScrambled[i], k_Halton[i + 1].x);
        
        // float3 dirTS = GenerateCosineWeightedHemisphereSamples(xi);
        float3 dirTS = InverseSampleHemisphere(xi.xy).xyz;
        // float3 dirTS = CosineSampleHemisphere(xi.xy).xyz;
        // float3 dirTS = FibonacciSpiralHemisphere(i, sampleCount);
        float cosTheta = dirTS.y;
        // float scale = xi.x;
        float scale = (i + 1) / sampleCount;
        dirTS *= scale * scale;
        dirTS.xz = mul(rotation, dirTS.xz);

        float3 dirWS = tangent * dirTS.x + normalWS * dirTS.y + binormal * dirTS.z;
        float3 sampleWS = originWS + dirWS * radius;
        float4 sampleHCS = TransformWorldToHClip(sampleWS);
        sampleHCS.xyz /= sampleHCS.w;
        float2 uv = sampleHCS.xy * 0.5 + 0.5;

        #if UNITY_UV_STARTS_AT_TOP
        uv.y = 1.0f - uv.y;
        #endif
        
        float sampledDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_LinearClamp, uv, 0).r;
        float linearDepth = GetViewDepthFromDepthTexture(sampledDepth);
        
        bool rangeCheck = abs(sampleHCS.w - linearDepth) < radius;
        float occlusion = (linearDepth < sampleHCS.w) * rangeCheck * intensity;
        aoFactor += (1 - occlusion) * cosTheta;
        weightSum += cosTheta;
    }

    aoFactor = saturate(aoFactor / weightSum);
    // TODO：可以在 PBR 中应用 interreflection ！！！！！！！！！
    // aoFactor = aoFactor * rcp(1 - GetSSAOReflectionRate() * (1 - aoFactor));
    _OutputTexture[id.xy] = float2(aoFactor, originDepth);
}

// ----------------------------------------------------------------------------------------------------
// Spatial Filter - Bilateral Filter
// ----------------------------------------------------------------------------------------------------

inline float2 LoadAOandDepth(float2 pixelCoord, float2 offset)
{
    return LOAD_TEXTURE2D_LOD(_InputTexture, pixelCoord + offset, 0).rg;
}

inline float BilateralWeight(float radiusDelta, float depthDelta)
{
    float spatialSigma = GetSpatialBlurSpatialSigma();
    float depthSigma = GetSpatialBlurDepthSigma();
    // float spatialFactor = radiusDelta * radiusDelta;
    // float depthFactor = abs(depthDelta) * _ProjectionParams.z;
    // float spatialWeight = exp((-spatialFactor) * rcp(2.0 * spatialSigma * spatialSigma));
    // float depthWeight = exp((-depthFactor) * rcp(2.0 * depthSigma * depthSigma));
    // return spatialWeight * depthWeight;

    // return exp2(-radiusDelta * radiusDelta * spatialSigma - abs(depthDelta) * depthSigma * _ProjectionParams.z);

    // TODO: depth threshold 学习 FXAA，绝对和相对阈值
    // return exp2(-radiusDelta * radiusDelta * spatialSigma) * ((abs(depthDelta) * _ProjectionParams.z) < 0.1);
    return exp(-radiusDelta * radiusDelta * rcp(2.0 * spatialSigma * spatialSigma)) * ((abs(depthDelta) * _ProjectionParams.z) < 0.1);
}

inline float2 BilateralBlur(float2 pixelCoord, float2 pixelOffset)
{
    int radius = int(GetSpatialBlurKernelRadius());
    float2 center = LoadAOandDepth(pixelCoord,0);
    float weightSum = BilateralWeight(0, 0);
    float aoFactor = center.r * weightSum;
    
    for (int i = -radius; i <= radius && i != 0; i++)
    {
        float2 sample = LoadAOandDepth(pixelCoord, i * pixelOffset);
        float weight = BilateralWeight(i, sample.g - center.g);
        aoFactor += sample.r * weight;
        weightSum += weight;
    }

    aoFactor /= weightSum;
    return float2(aoFactor, center.g);
}

// ----------------------------------------------------------------------------------------------------
// Temporal Filter
// ----------------------------------------------------------------------------------------------------

float GaussianFilterMiddleColor(in float2 samples[9])
{
    // const float weights[9] = { 4.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0 };
    // sigma = 0.8
    // const float weights[9] = { 1.0, 0.4578, 0.4578, 0.4578, 0.4578, 0.2097, 0.2097, 0.2097, 0.2097 };
    
    // sigma = 0.6
    const float weights[9] = { 1.0, 0.2493, 0.2493, 0.2493, 0.2493, 0.0625, 0.0625, 0.0625, 0.0625 };
    
    float weightSum = 4.0;
    float filtered = weightSum * samples[0].r;

    for (int i = 0; i < 8; i++)
    {
        float weight = weights[i + 1];
        weightSum += weight;
        filtered += weight * samples[i + 1].r;
    }
    filtered *= rcp(weightSum);
    return filtered;
}

void VarianceNeighbourhood(in float2 samples[9], float filtered, float gamma, out float2 minMax)
{
    float m1 = 0;
    float m2 = 0;
    for (int i = 0; i < 9; i++)
    {
        float sampleColor = samples[i].r;
        m1 += sampleColor;
        m2 += sampleColor * sampleColor;
    }

    const int sampleCount = 9;
    m1 *= rcp(sampleCount);
    m2 *= rcp(sampleCount);

    float sigma = sqrt(abs(m2 - m1 * m1)); // standard deviation
    float neighborMin = m1 - gamma * sigma;
    float neighborMax = m1 + gamma * sigma;

    neighborMin = min(neighborMin, filtered);
    neighborMax = max(neighborMax, filtered);

    minMax = float2(neighborMin, neighborMax);
}

float NeighborhoodClipToFiltered(float2 minMax, float filtered, float history)
{
    float boxMin = minMax.x;
    float boxMax = minMax.y;

    float rayOrigin = history;
    float rayDir = filtered - history;
    rayDir = abs(rayDir) < HALF_MIN ? HALF_MIN : rayDir;
    float invDir = rcp(rayDir);
    
    float minIntersect = (boxMin - rayOrigin) * invDir;
    float maxIntersect = (boxMax - rayOrigin) * invDir;
    float enterIntersect = min(minIntersect, maxIntersect);
    float historyBlend = saturate(enterIntersect);
    return lerp(history, filtered, historyBlend);
}

inline float2 TemporalBlur(float2 pixelCoord, float2 screenUV)
{
    float2 velocity = SAMPLE_TEXTURE2D_LOD(_MotionVectorTexture, sampler_PointClamp, screenUV, 0).rg;
    float2 historyUV = screenUV - velocity;
    float2 history = SAMPLE_TEXTURE2D_LOD(_AmbientOcclusionHistory, sampler_LinearClamp, historyUV, 0);

    float2 neighbours[9];
    neighbours[0] = LoadAOandDepth(pixelCoord,0);
    neighbours[1] = LoadAOandDepth(pixelCoord, int2(0, 1));
    neighbours[2] = LoadAOandDepth(pixelCoord, int2(1, 0));
    neighbours[3] = LoadAOandDepth(pixelCoord, int2(0, -1));
    neighbours[4] = LoadAOandDepth(pixelCoord, int2(-1, 0));
    neighbours[5] = LoadAOandDepth(pixelCoord, int2(-1, 1));
    neighbours[6] = LoadAOandDepth(pixelCoord, int2(1, 1));
    neighbours[7] = LoadAOandDepth(pixelCoord, int2(-1, -1));
    neighbours[8] = LoadAOandDepth(pixelCoord, int2(1, -1));

    // float prefiltered = neighbours[0].r;
    float prefiltered = GaussianFilterMiddleColor(neighbours);

    float2 minMax;
    VarianceNeighbourhood(neighbours, prefiltered, 1.25, minMax);
    
    history.r = NeighborhoodClipToFiltered(minMax, prefiltered, history.r);
    
    return float2(lerp(neighbours[0].r, history.r, 0.9), neighbours[0].g);
}

// ----------------------------------------------------------------------------------------------------
// Filter Kernels
// ----------------------------------------------------------------------------------------------------

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void SpatialBlurHorizontalKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;
    _OutputTexture[id.xy] = BilateralBlur(id.xy, float2(1, 0));
}

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void SpatialBlurVerticalKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;
    _OutputTexture[id.xy] = BilateralBlur(id.xy, float2(0, 1));
}

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void TemporalBlurKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;

    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    _OutputTexture[id.xy] = TemporalBlur(id.xy, screenUV);
}