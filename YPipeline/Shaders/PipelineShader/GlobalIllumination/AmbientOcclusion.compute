#pragma kernel SSAOKernel
#pragma kernel DepthDownsampleKernel
#pragma kernel SpatialBlurHorizontalKernel
#pragma kernel SpatialBlurVerticalKernel
#pragma kernel TemporalBlurKernel

#pragma multi_compile _ _HALF_RESOLUTION

#include "../../../ShaderLibrary/Core/YPipelineCSCore.hlsl"
#include "../../../ShaderLibrary/RandomLibrary.hlsl"
#include "../../../ShaderLibrary/SamplingLibrary.hlsl"
#include "../../../ShaderLibrary/EncodingLibrary.hlsl"

RWTexture2D<float2> _OutputTexture;
Texture2D<float2> _InputTexture;
Texture2D<float> _HalfDepthTexture;
Texture2D<float2> _AmbientOcclusionHistory;

TEXTURE2D(_ThinGBuffer);
TEXTURE2D(_CameraDepthTexture);
TEXTURE2D(_MotionVectorTexture);
TEXTURE2D(_BlueNoise64);
float4 _BlueNoise64_TexelSize;
SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_PointClamp);

#include "../../../ShaderLibrary/GlobalIllumination/SSAO.hlsl"

float4 _CameraBufferSize; // x: 1.0 / bufferSize.x, y: 1.0 / bufferSize.y, z: bufferSize.x, w: bufferSize.y
float4 _Jitter; // Halton (-0.5, 0.5), xy: 1.0 / jitter, zw: jitter

float4 _TextureSize; // x: 1.0 / width, y: 1.0 / height, z: width, w: height
// SSAO - x: intensity, y: sample count, z: radius
// HBAO - x: , y: , z: , w:
// GTAO - x: , y: , z: , w: 
float4 _AmbientOcclusionParams;
float4 _AOSpatialBlurParams; // x: kernel radius, y: spatial sigma, z: depth/range sigma

#define MAX_FILTER_RADIUS 6
groupshared float2 _AOAndDepth[64 + 2 * MAX_FILTER_RADIUS];

// ----------------------------------------------------------------------------------------------------
// Input
// ----------------------------------------------------------------------------------------------------

inline float GetSSAOIntensity()             { return _AmbientOcclusionParams.x; }
inline float GetSSAOSampleCount()           { return _AmbientOcclusionParams.y; }
inline float GetSSAORadius()                { return _AmbientOcclusionParams.z; }
inline float GetSSAOReflectionRate()        { return _AmbientOcclusionParams.w; }
inline float GetSpatialBlurKernelRadius()   { return _AOSpatialBlurParams.x; }
inline float2 GetSpatialBlurSigma()         { return _AOSpatialBlurParams.yz; }

// ----------------------------------------------------------------------------------------------------
// SSAO Kernel
// ----------------------------------------------------------------------------------------------------

[numthreads(8, 8, 1)]
void SSAOKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;

    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    
    // ------------------------- Get Origin Position -------------------------
    
    float originDepth = LoadDepth(id.xy);
    float4 originNDC = GetNDCFromUVAndDepth(screenUV, originDepth);
    float3 originWS = TransformNDCToWorld(originNDC, UNITY_MATRIX_I_VP);

    // ------------------------- Get Normal & Build Left-Handed TBN -------------------------
    
    float3 normalWS = LoadAndDecodeNormal(id.xy); // N

    float3 up = abs(normalWS.y) > 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);
    float3 tangent = normalize(cross(up, normalWS)); // T
    float3 binormal = normalize(cross(tangent, normalWS)); // B

    // ------------------------- Random Rotation -------------------------

    // TODO: Temporal Filter
    // float randomRadian = (LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.w, 0).r) * TWO_PI;
    float randomRadian = (LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.w, 0).r + _Jitter.z) * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));

    // ------------------------- SSAO Loop -------------------------
    
    float aoFactor = 0.0;
    float intensity = GetSSAOIntensity();
    float sampleCount = GetSSAOSampleCount();
    float radius = GetSSAORadius();

    UNITY_UNROLL
    for (int i = 0; i < sampleCount; i++)
    {
        // ------------------------- Generate Hemisphere Samples -------------------------
        
        float2 xi = k_Sobol[i + 1];
        // float scale = max(k_Halton[i + 1].y, 0.01);
        float scale = max(k_Halton[i + 1].y + _Jitter.z * 0.01, 0.01);
        float3 dirTS = GenerateCosineWeightedHemisphereSamples(xi, scale);
        dirTS.xz = mul(rotation, dirTS.xz);

        // ------------------------- Sample Depth Buffer -------------------------
        
        float3 dirWS = tangent * dirTS.x + normalWS * dirTS.y + binormal * dirTS.z;
        float3 sampleWS = originWS + dirWS * radius;
        float4 sampleHCS = TransformWorldToHClip(sampleWS);
        sampleHCS.xyz /= sampleHCS.w;
        float2 uv = sampleHCS.xy * 0.5 + 0.5;

        #if UNITY_UV_STARTS_AT_TOP
        uv.y = 1.0f - uv.y;
        #endif

        int2 pixelCoord = clamp(uv * _TextureSize.zw, 0, _TextureSize.zw - 1);
        float sampledDepth = LoadDepth(pixelCoord);
        float linearDepth = GetViewDepthFromDepthTexture(sampledDepth);

        // ------------------------- Accumulate Occlusion Factor -------------------------
        
        bool rangeCheck = abs(sampleHCS.w - linearDepth) < radius;
        float occlusion = (linearDepth + 0.01 < sampleHCS.w) * rangeCheck * intensity;
        aoFactor += 1.0 - occlusion;
    }
    
    aoFactor = saturate(aoFactor / sampleCount);
    _OutputTexture[id.xy] = float2(aoFactor, originDepth);
}

// ----------------------------------------------------------------------------------------------------
// Depth Downsample Kernel
// ----------------------------------------------------------------------------------------------------

[numthreads(8, 8, 1)]
void DepthDownsampleKernel(uint3 id : SV_DispatchThreadID)
{
    int2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    _OutputTexture[id.xy] = LOAD_TEXTURE2D_LOD(_CameraDepthTexture, pixelCoord * 2, 0).r;
}

// ----------------------------------------------------------------------------------------------------
// Filter Kernels
// ----------------------------------------------------------------------------------------------------

[numthreads(64, 1, 1)]
void SpatialBlurHorizontalKernel(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
    // ------------------------- Fetch AO & Depth -------------------------

    int2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    _AOAndDepth[groupIndex + MAX_FILTER_RADIUS] = LoadAOandDepth(pixelCoord);

    if (groupIndex < MAX_FILTER_RADIUS)
    {
        int2 extraCoord = pixelCoord - int2(MAX_FILTER_RADIUS, 0);
        extraCoord = clamp(extraCoord, 0, _TextureSize.zw - 1);
        _AOAndDepth[groupIndex] = LoadAOandDepth(extraCoord);
    }

    if (groupIndex >= 64 - MAX_FILTER_RADIUS)
    {
        int2 extraCoord = pixelCoord + int2(MAX_FILTER_RADIUS, 0);
        extraCoord = clamp(extraCoord, 0, _TextureSize.zw - 1);
        _AOAndDepth[groupIndex + 2 * MAX_FILTER_RADIUS] = LoadAOandDepth(extraCoord);
    }
    
    GroupMemoryBarrierWithGroupSync();

    // ------------------------- Bilateral Blur -------------------------

    float2 middle = _AOAndDepth[groupIndex + MAX_FILTER_RADIUS];
    float middleDepth = GetViewDepthFromDepthTexture(middle.g);
    float weightSum = 0.0;
    float aoFactor = 0.0;
        
    int radius = int(GetSpatialBlurKernelRadius());
    for (int i = -radius; i <= radius; i++)
    {
        float2 sample = _AOAndDepth[groupIndex + MAX_FILTER_RADIUS + i];
        float sampleDepth = GetViewDepthFromDepthTexture(sample.g);
        float depthDelta = abs(sampleDepth - middleDepth);
        float weight = BilateralWeight(i, depthDelta, GetSpatialBlurSigma());
        aoFactor += sample.r * weight;
        weightSum += weight;
    }
    aoFactor /= weightSum;
    _OutputTexture[id.xy] = float2(aoFactor, middle.g);
}

[numthreads(1, 64, 1)]
void SpatialBlurVerticalKernel(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
    // ------------------------- Fetch AO & Depth -------------------------
    
    int2 pixelCoord = clamp(id.xy, 0, _TextureSize.zw - 1);
    _AOAndDepth[groupIndex + MAX_FILTER_RADIUS] = LoadAOandDepth(pixelCoord);

    if (groupIndex < MAX_FILTER_RADIUS)
    {
        int2 extraCoord = pixelCoord - int2(0, MAX_FILTER_RADIUS);
        extraCoord = clamp(extraCoord, 0, _TextureSize.zw - 1);
        _AOAndDepth[groupIndex] = LoadAOandDepth(extraCoord);
    }

    if (groupIndex >= 64 - MAX_FILTER_RADIUS)
    {
        int2 extraCoord = pixelCoord + int2(0, MAX_FILTER_RADIUS);
        extraCoord = clamp(extraCoord, 0, _TextureSize.zw - 1);
        _AOAndDepth[groupIndex + 2 * MAX_FILTER_RADIUS] = LoadAOandDepth(extraCoord);
    }
    
    GroupMemoryBarrierWithGroupSync();

    // ------------------------- Bilateral Blur -------------------------

    float2 middle = _AOAndDepth[groupIndex + MAX_FILTER_RADIUS];
    float middleDepth = GetViewDepthFromDepthTexture(middle.g);
    float weightSum = 0.0;
    float aoFactor = 0.0;
        
    int radius = int(GetSpatialBlurKernelRadius());
    for (int i = -radius; i <= radius; i++)
    {
        float2 sample = _AOAndDepth[groupIndex + MAX_FILTER_RADIUS + i];
        float sampleDepth = GetViewDepthFromDepthTexture(sample.g);
        float depthDelta = abs(sampleDepth - middleDepth);
        float weight = BilateralWeight(i, depthDelta, GetSpatialBlurSigma());
        aoFactor += sample.r * weight;
        weightSum += weight;
    }
    aoFactor /= weightSum;
    _OutputTexture[id.xy] = float2(aoFactor, middle.g);
}

[numthreads(8, 8, 1)]
void TemporalBlurKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;

    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    _OutputTexture[id.xy] = TemporalBlur(id.xy, screenUV);
}