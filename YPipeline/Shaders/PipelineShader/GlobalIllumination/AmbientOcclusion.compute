#pragma kernel SSAOKernel
#pragma kernel SpatialBlurHorizontalKernel
#pragma kernel SpatialBlurVerticalKernel

#define THREAD_NUM_X 8
#define THREAD_NUM_Y 8

#include "../../../ShaderLibrary/Core/YPipelineCSCore.hlsl"
#include "../../../ShaderLibrary/RandomLibrary.hlsl"
#include "../../../ShaderLibrary/SamplingLibrary.hlsl"
#include "../../../ShaderLibrary/EncodingLibrary.hlsl"

RWTexture2D<float4> _OutputTexture;
Texture2D<float4> _InputTexture;

TEXTURE2D(_ThinGBuffer0);
TEXTURE2D(_CameraDepthTexture);
TEXTURE2D(_BlueNoise64);
float4 _BlueNoise64_TexelSize;
SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_PointClamp);

float4 _CameraBufferSize; // x: 1.0 / bufferSize.x, y: 1.0 / bufferSize.y, z: bufferSize.x, w: bufferSize.y
float4 _Jitter; // Halton (0, 1), xy: 1.0 / jitter, zw: jitter

float4 _TextureSize; // x: 1.0 / width, y: 1.0 / height, z: width, w: height

// SSAO - x: intensity, y: sample count, z: radius, w: reflection rate
// HBAO - x: , y: , z: , w:
// GTAO - x: , y: , z: , w: 
float4 _AmbientOcclusionParams;
float4 _AOSpatialBlurParams; // x: kernel radius, y: sigma

// ----------------------------------------------------------------------------------------------------
// Input
// ----------------------------------------------------------------------------------------------------

inline float GetSSAOIntensity()             { return _AmbientOcclusionParams.x; }
inline float GetSSAOSampleCount()           { return _AmbientOcclusionParams.y; }
inline float GetSSAORadius()                { return _AmbientOcclusionParams.z; }
inline float GetSSAOReflectionRate()        { return _AmbientOcclusionParams.w; }
inline float GetSpatialBlurKernelRadius()   { return _AOSpatialBlurParams.x; }
inline float GetSpatialBlurKernelSigma()    { return _AOSpatialBlurParams.y; }

// ----------------------------------------------------------------------------------------------------
// AO Kernels
// ----------------------------------------------------------------------------------------------------

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void SSAOKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;

    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    
    // ------------------------- Get Depth -------------------------
    
    float originDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_LinearClamp, screenUV, 0).r;
    float4 originNDC = GetNDCFromUVAndDepth(screenUV, originDepth);
    float3 originWS = TransformNDCToWorld(originNDC, UNITY_MATRIX_I_VP);

    // ------------------------- Get Normal & Build Left-Handed TBN -------------------------
    
    float3 packNormalWS = SAMPLE_TEXTURE2D_LOD(_ThinGBuffer0, sampler_LinearClamp, screenUV, 0).rgb;
    float3 normalWS = normalize(packNormalWS * 2.0 - 1.0); // N

    float3 up = abs(normalWS.y) > 0.999999 ? float3(0, 0, 1) : float3(0, 1, 0);
    float3 tangent = normalize(cross(up, normalWS)); // T
    float3 binormal = normalize(cross(tangent, normalWS)); // B

    // ------------------------- Generate Normal-Oriented Hemisphere Samples -------------------------

    // TODO: Temporal Filter
    // float randomRadian = (LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.w, 0).r + _Jitter.w) * TWO_PI;
    float randomRadian = LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.w, 0).r * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));

    float aoFactor = 0.0;
    float intensity = GetSSAOIntensity();
    float sampleCount = GetSSAOSampleCount();
    float radius = GetSSAORadius();

    UNITY_UNROLL
    for (int i = 0; i < sampleCount; i++)
    {
        float2 xi = k_Halton[i + 1];
        float3 dirTS = InverseSampleHemisphere(xi).xyz;
        float cosTheta = dirTS.y;
        float random = k_Sobol[i + 1].y;
        dirTS *= random * random;
        dirTS.xz = mul(rotation, dirTS.xz);

        float3 dirWS = tangent * dirTS.x + normalWS * dirTS.y + binormal * dirTS.z;
        float3 sampleWS = originWS + dirWS * radius;
        float4 sampleHCS = TransformWorldToHClip(sampleWS);
        sampleHCS.xyz /= sampleHCS.w;
        float2 uv = sampleHCS.xy * 0.5 + 0.5;

        #if UNITY_UV_STARTS_AT_TOP
        uv.y = 1.0f - uv.y;
        #endif
        
        float sampledDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_LinearClamp, uv, 0).r;
        float linearDepth = GetViewDepthFromDepthTexture(sampledDepth);
        
        bool rangeCheck = abs(sampleHCS.w - linearDepth) < radius;
        float occlusion = (linearDepth < sampleHCS.w) * rangeCheck * intensity;
        aoFactor += (1 - occlusion) * cosTheta;
    }

    aoFactor = saturate(2.0 * aoFactor / sampleCount);
    aoFactor = aoFactor * rcp(1 - GetSSAOReflectionRate() * (1 - aoFactor));
    _OutputTexture[id.xy] = float4(aoFactor, packNormalWS);
}

// ----------------------------------------------------------------------------------------------------
// Gaussian Filter
// ----------------------------------------------------------------------------------------------------

// From https://www.intel.com/content/www/us/en/developer/articles/technical/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms.html
// Kernel width 7 x 7
float GaussianBlur(TEXTURE2D(tex), float2 screenUV, float2 offset)
{
    const int stepCount = 2;
    const float offsets[stepCount] = { 0.53805, 2.06278 };
    const float weights[stepCount] = { 0.44908, 0.05092 };
    float aoFactor = 0.0;

    UNITY_UNROLL
    for (int i = 0; i < stepCount; i++)
    {
        float2 uvOffset = offsets[i] * offset;
        float sample = SAMPLE_TEXTURE2D_LOD(tex, sampler_LinearClamp, screenUV + uvOffset, 0).r
        + SAMPLE_TEXTURE2D_LOD(tex, sampler_LinearClamp, screenUV - uvOffset, 0).r;
        aoFactor += sample * weights[i];
    }
    return aoFactor;
}

// ----------------------------------------------------------------------------------------------------
// Bilateral Filter
// ----------------------------------------------------------------------------------------------------

// inline float4 LoadAOandNormal(TEXTURE2D(tex), float2 pixelCoord, float2 offset)
// {
//     float4 sample = LOAD_TEXTURE2D_LOD(tex, pixelCoord + offset, 0);
//     return float4(sample.r, sample.gba * 2.0 - 1.0);
// }

// TODO: 用深度判断比 normal 好！！！！！！！！！
inline float4 SampleAOandNormal(TEXTURE2D(tex), float2 screenUV, float2 offset)
{
    float4 sample = SAMPLE_TEXTURE2D_LOD(tex, sampler_LinearClamp, screenUV + offset, 0);
    return float4(sample.r, sample.gba * 2.0 - 1.0);
}

// TODO：两个 sigma
inline float BilateralWeight(float radiusDelta, float3 normalDelta, float sigma)
{
    float spaceFactor = radiusDelta * radiusDelta;
    float normalFactor = dot(normalDelta, normalDelta) * 1;
    float spaceWeight = exp((-spaceFactor) * rcp(2.0 * sigma * sigma));
    float normalWeight = exp((-normalFactor) * rcp(2.0 * 1 * 1));
    return spaceWeight * normalWeight;
}

inline float4 BilateralBlur(TEXTURE2D(tex), float2 screenUV, float2 offset, float sigma)
{
    float4 p0 =  SampleAOandNormal(tex, screenUV, 0);
    float4 p1a = SampleAOandNormal(tex, screenUV, offset * -1.3846153846);
    float4 p1b = SampleAOandNormal(tex, screenUV, offset * 1.3846153846);
    float4 p2a = SampleAOandNormal(tex, screenUV, offset * -3.2307692308);
    float4 p2b = SampleAOandNormal(tex, screenUV, offset * 3.2307692308);

    float w0  = BilateralWeight(0,0, sigma);
    float w1a = BilateralWeight(1.3846153846,p1a.gba - p0.gba, sigma);
    float w1b = BilateralWeight(1.3846153846,p1b.gba - p0.gba, sigma);
    float w2a = BilateralWeight(3.2307692308,p2a.gba - p0.gba, sigma);
    float w2b = BilateralWeight(3.2307692308,p1b.gba - p0.gba, sigma);

    float ao = 0.0;
    ao += p0.r  * w0;
    ao += p1a.r * w1a;
    ao += p1b.r * w1b;
    ao += p2a.r * w2a;
    ao += p2b.r * w2b;
    ao *= rcp(w0 + w1a + w1b + w2a + w2b);

    return float4(ao, p0.gba * 0.5 + 0.5);
}

// ----------------------------------------------------------------------------------------------------
// Filter Kernels
// ----------------------------------------------------------------------------------------------------

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void SpatialBlurHorizontalKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;

    // Gaussian Blur
    // float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    // float occlusion = GaussianBlur(_InputTexture, screenUV, float2(_TextureSize.x, 0));
    // _OutputTexture[id.xy] = occlusion;
    
    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    _OutputTexture[id.xy] = BilateralBlur(_InputTexture, screenUV, float2(_TextureSize.x, 0), GetSpatialBlurKernelSigma());
}

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void SpatialBlurVerticalKernel(uint3 id : SV_DispatchThreadID)
{
    bool inScreen = all(float2(id.xy) < _TextureSize.zw);
    if (!inScreen) return;

    // Gaussian Blur
    // float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    // float occlusion = GaussianBlur(_InputTexture, screenUV, float2(0, _TextureSize.y));
    // _OutputTexture[id.xy] = occlusion;
    
    float2 screenUV = (float2(id.xy) + float2(0.5, 0.5)) * _TextureSize.xy;
    _OutputTexture[id.xy] = BilateralBlur(_InputTexture, screenUV, float2(0, _TextureSize.y), GetSpatialBlurKernelSigma());
}