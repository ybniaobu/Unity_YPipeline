#pragma kernel TiledLightCulling

#define THREAD_NUM_X 16
#define THREAD_NUM_Y 16

#include "../../ShaderLibrary/Core/YPipelineCSCore.hlsl"

#define MAX_PUNCTUAL_LIGHT_COUNT 256
#define MAX_LIGHT_COUNT_PER_TILE 32

StructuredBuffer<float4> _LightsCullingInputBuffer;
RWStructuredBuffer<uint> _TilesLightIndicesBuffer;
float4 _TileParams; // xy: tileCountXY, zw: tileUVSizeXY

groupshared uint lightCountInTile = 0;
groupshared uint lightIndicesInTile[MAX_PUNCTUAL_LIGHT_COUNT];
// groupshared uint tileMinDepthInt = 0xFFFFFFFF;
// groupshared uint tileMaxDepthInt = 0;

[numthreads(THREAD_NUM_X, THREAD_NUM_Y, 1)]
void TiledLightCulling(uint3 id : SV_DispatchThreadID, uint3 groupThreadId : SV_GroupThreadID, uint3 groupId : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    if (groupIndex == 0)
    {
        lightCountInTile = 0;
    }

    GroupMemoryBarrierWithGroupSync();
    
    // bool inScreen = (float)id.x < _CameraBufferSize.x && (float)id.y < _CameraBufferSize.y;
    // if (!inScreen) return;
    
    float4 tileBound = float4(groupId.x, groupId.y, groupId.x + 1, groupId.y + 1) * _TileParams.zwzw;
    float4 lightBound = _LightsCullingInputBuffer[groupIndex];

    // Intersect
    if ((lightBound.x < tileBound.z) && (lightBound.y < tileBound.w) && (tileBound.x < lightBound.z) && (tileBound.y < lightBound.w))
    {
        uint offset;
        InterlockedAdd(lightCountInTile, 1, offset);
        lightIndicesInTile[offset] = groupIndex;
    }
    
    GroupMemoryBarrierWithGroupSync();

    uint headerIndex = (groupId.y * _TileParams.x + groupId.x) * (MAX_LIGHT_COUNT_PER_TILE + 1);
    uint minLightCount = min(lightCountInTile, MAX_LIGHT_COUNT_PER_TILE);
    
    if (groupIndex == 0)
    {
        _TilesLightIndicesBuffer[headerIndex] = lightCountInTile;
    }
    else
    {
        if (groupIndex - 1 < minLightCount) _TilesLightIndicesBuffer[headerIndex + groupIndex] = lightIndicesInTile[groupIndex - 1];
    }
}
